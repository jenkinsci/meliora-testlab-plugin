package fi.meliora.testlab.ext.jenkins;

import hudson.*;
import hudson.model.*;
import hudson.tasks.*;
import hudson.util.PluginServletFilter;
import net.sf.json.JSONObject;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.StaplerRequest;

import javax.servlet.ServletException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A post build action to publish test results to Meliora Testlab.
 *
 * @author Meliora Ltd
 */
public class TestlabNotifier extends Notifier {
    private final static Logger log = Logger.getLogger(TestlabNotifier.class.getName());

    /*
        BuildSteps that run after the build is completed.

        Notifier is a kind of Publisher that sends out the outcome of the builds
        to other systems and humans. This marking ensures that notifiers are run
        after the build result is set to its final value by other Recorders. To run
        even after the build is marked as complete, override Publisher.needsToRunAfterFinalized()
        to return true.
     */

    public static final String DEFAULT_COMMENT_TEMPLATE
            = "Jenkins build: ${BUILD_FULL_DISPLAY_NAME} ${BUILD_RESULT}, ${BUILD_URL} - ${BUILD_STATUS}";

    // project key which to publish the results to
    public String projectKey;
    // source to use to map the results to test case
    public String source;
    // overridden source settings
    public SourceSettings sourceSettings;

    // comment of the test run to create or update at Testlab side
    public String comment;
    // tags for the test run
    public String tags;
    // test case parameters to send from environmental variables
    public String parameters;
    // If set, publish Robot Framework results
    public PublishRobot publishRobot;
    // if set, publish TAP results
    public PublishTap publishTap;
    // holder for optional advanced settings
    public AdvancedSettings advancedSettings;

    /* pre-source configuration, see readResolve */
    private transient String testRunTitle;
    private transient String milestone;
    private transient String testTargetTitle;
    private transient String testEnvironmentTitle;
    private transient IssuesSettings issuesSettings;
    private transient ImportTestCases importTestCases;
    /* /pre-source configuration */

    protected Object readResolve() {
        //// migrate "pre-source" configuration, if any

        if(!isBlank(testRunTitle)) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.testRunTitle = testRunTitle;
            log.info("Migrated pre-source configuration testRunTitle: " + testRunTitle);
            testRunTitle = null;
        }

        if(!isBlank(milestone)) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.milestone = milestone;
            log.info("Migrated pre-source configuration milestone: " + milestone);
            milestone = null;
        }

        if(!isBlank(testTargetTitle)) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.testTargetTitle = testTargetTitle;
            log.info("Migrated pre-source configuration testTargetTitle: " + testTargetTitle);
            testTargetTitle = null;
        }

        if(!isBlank(testEnvironmentTitle)) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.testEnvironmentTitle = testEnvironmentTitle;
            log.info("Migrated pre-source configuration testEnvironmentTitle: " + testEnvironmentTitle);
            testEnvironmentTitle = null;
        }

        if(issuesSettings != null) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.addIssues = true;
            sourceSettings.mergeAsSingleIssue = issuesSettings.mergeAsSingleIssue;
            sourceSettings.assignToUser = issuesSettings.assignToUser;
            sourceSettings.reopenExisting = issuesSettings.reopenExisting;
            log.info("Migrated pre-source configuration issuesSettings: " + issuesSettings);
            issuesSettings = null;
        }

        if(importTestCases != null) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.importTestCases = true;
            sourceSettings.importTestCasesRootCategory = importTestCases.importTestCasesRootCategory;
            log.info("Migrated pre-source configuration importTestCases: " + importTestCases);
            importTestCases = null;
        }

        if(advancedSettings != null && !isBlank(advancedSettings.testCaseMappingField)) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.testCaseMappingField = advancedSettings.testCaseMappingField;
            log.info("Migrated pre-source configuration advancedSettings.testCaseMappingField: " + advancedSettings.testCaseMappingField);
            advancedSettings.testCaseMappingField = null;
        }

        if(publishRobot != null && publishRobot.robotCatenateParentKeywords != null && !publishRobot.robotCatenateParentKeywords) {
            if(sourceSettings == null)
                sourceSettings = new SourceSettings();
            sourceSettings.robotCatenateParentKeywords = publishRobot.robotCatenateParentKeywords;
            log.info("Migrated pre-source configuration publishRobot.robotCatenateParentKeywords: " + publishRobot.robotCatenateParentKeywords);
        }

        log.severe("Configuration resolved: " + this);

        return this;
    }

    /**
     * This annotation tells Hudson to call this constructor, with
     * values from the configuration form page with matching parameter names.
     */
    @DataBoundConstructor
    public TestlabNotifier(String projectKey, String source, SourceSettings sourceSettings, String comment, String tags, String parameters, PublishRobot publishRobot, PublishTap publishTap, AdvancedSettings advancedSettings) {
//    public TestlabNotifier(String projectKey, String source, String testRunTitle, String comment, String milestone, String testTargetTitle, String testEnvironmentTitle, String tags, String parameters, IssuesSettings issuesSettings, AdvancedSettings advancedSettings, PublishRobot publishRobot, PublishTap publishTap, ImportTestCases importTestCases) {
        this.projectKey = projectKey;
        this.source = source;
        this.sourceSettings = sourceSettings;
        this.comment = comment;
        this.tags = tags;
        this.parameters = parameters;
        this.publishRobot = publishRobot;
        this.publishTap = publishTap;
        this.advancedSettings = advancedSettings;

//        this.projectKey = projectKey;
//        this.source = source;
//
//        this.testRunTitle = testRunTitle;
//        this.comment = comment;
//        this.milestone = milestone;
//        this.testTargetTitle = testTargetTitle;
//        this.testEnvironmentTitle = testEnvironmentTitle;
//        this.tags = tags;
//        this.parameters = parameters;
//
//        this.issuesSettings = issuesSettings;
////        if(issuesSettings != null) {
////            this.mergeAsSingleIssue = issuesSettings.isMergeAsSingleIssue();
////            this.assignToUser = issuesSettings.getAssignToUser();
////            this.reopenExisting = issuesSettings.isReopenExisting();
////        }
//
//        this.advancedSettings = advancedSettings;
////        if(advancedSettings != null) {
////            this.companyId = advancedSettings.getCompanyId();
////            this.apiKey = advancedSettings.getApiKey();
////            this.testCaseMappingField = advancedSettings.getTestCaseMappingField();
//            this.usingonpremise = advancedSettings.getUsingonpremise();
////        }
//
//        this.publishRobot = publishRobot;
////        if(publishRobot != null) {
////            this.robotOutput = publishRobot.getRobotOutput();
////            this.robotCatenateParentKeywords = publishRobot.isRobotCatenateParentKeywords();
////        }
//
//        this.publishTap = publishTap;
////        if(publishTap != null) {
////            this.tapFileNameInIdentifier = publishTap.isTapFileNameInIdentifier();
////            this.tapTestNumberInIdentifier = publishTap.isTapTestNumberInIdentifier();
////            this.tapTestsAsSteps = publishTap.isTapTestsAsSteps();
////            this.tapMappingPrefix = publishTap.getTapMappingPrefix();
////        }
//
//        this.importTestCases = importTestCases;
////        if(importTestCases != null) {
////            this.importTestCasesRootCategory = importTestCases.getImportTestCasesRootCategory();
////        }
    }

    /**
     * Return true if this {@link hudson.tasks.Publisher} needs to run after the build result is
     * fully finalized.
     * <p/>
     * <p/>
     * The execution of normal {@link hudson.tasks.Publisher}s are considered within a part
     * of the build. This allows publishers to mark the build as a failure, or
     * to include their execution time in the total build time.
     * <p/>
     * <p/>
     * So normally, that is the preferrable behavior, but in a few cases
     * this is problematic. One of such cases is when a publisher needs to
     * trigger other builds, which in turn need to see this build as a
     * completed build. Those plugins that need to do this can return true
     * from this method, so that the {@link #perform(hudson.model.AbstractBuild, hudson.Launcher, hudson.model.BuildListener)}
     * method is called after the build is marked as completed.
     * <p/>
     * <p/>
     * When {@link hudson.tasks.Publisher} behaves this way, note that they can no longer
     * change the build status anymore.
     *
     * @author Kohsuke Kawaguchi
     * @since 1.153
     */
    @Override
    public boolean needsToRunAfterFinalized() {
        return true;
    }

    /**
     * Declares the scope of the synchronization monitor this {@link hudson.tasks.BuildStep} expects from outside.
     *
     * @since 1.319
     */
    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.STEP;
    }

    /**
     * Runs the step over the given build and reports the progress to the listener.
     *
     * A plugin can contribute the action object to Actionable.getActions() so that a 'report'
     * becomes a part of the persisted data of Build. This is how JUnit plugin attaches the
     * test report to a build page, for example.
     *
     * Using the return value to indicate success/failure should be considered deprecated,
     * and implementations are encouraged to throw AbortException to indicate a failure.
     *
     * @param build
     * @param launcher
     * @param listener
     * @return
     * @throws InterruptedException
     * @throws IOException
     */
    @Override
    public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {
        listener.getLogger().println("Publishing test results to Testlab project: " + projectKey);

        DescriptorImpl d = getDescriptor();

        log.fine("perform(): " + this + ", descriptor: " + d);

        // get job specific settings if any and fallback to global configuration
        String runApiKey = isBlank(advancedSettings != null ? advancedSettings.apiKey : null) ? d.apiKey : advancedSettings.apiKey;
//        String runTestCaseMappingField = isBlank(testCaseMappingField) ? d.getTestCaseMappingField() : testCaseMappingField;

        Usingonpremise uop = advancedSettings != null && advancedSettings.usingonpremise != null
                ? advancedSettings.usingonpremise : d.usingonpremise;

        String runCompanyId = null, runOnpremiseurl = null;
        boolean runUsingonpremise = false;

        if(uop != null && !isBlank(uop.onpremiseurl)) {
            //
            // we apply onpremise settings only if they are complete
            //
            runCompanyId = null;
            runUsingonpremise = true;
            runOnpremiseurl = uop.onpremiseurl;

            log.fine("using on-premise with url: " + runOnpremiseurl);

        } else {
            //
            // otherwise we use companyId if present
            //
            runCompanyId = !isBlank(advancedSettings != null ? advancedSettings.companyId : null) ? advancedSettings.companyId : d.companyId;

            log.fine("using hosted with company id: " + runCompanyId);
        }

        // replace env vars for applicable fields

        EnvVars envVars = build.getEnvironment(listener);

        Map<String, String> additionalKeys = new HashMap<String, String>();
        additionalKeys.put("BUILD_FULL_DISPLAY_NAME", build.getFullDisplayName());
        Run.Summary summary = build.getBuildStatusSummary();
        additionalKeys.put("BUILD_STATUS", summary.message != null ? summary.message : "[No build status available]");
        Result result = build.getResult();
        additionalKeys.put("BUILD_RESULT", result != null ? result.toString() : "[No build result available]");

        VariableReplacer vr = new VariableReplacer(envVars, additionalKeys);

        if(log.isLoggable(Level.FINE)) {
            log.fine("Environment variables:");
            for(String key : vr.getVars().keySet()) {
                log.fine(" " + key + "=" + vr.getVars().get(key));
            }
        }

        String runProjectKey = vr.replace(projectKey);
        String runMilestone = vr.replace(sourceSettings != null ? sourceSettings.milestone : null);
        String runTestRunTitle = vr.replace(sourceSettings != null ? sourceSettings.testRunTitle : null);
        String runComment = vr.replace(isBlank(comment) ? DEFAULT_COMMENT_TEMPLATE : comment);
        String runTestTargetTitle = vr.replace(sourceSettings != null ? sourceSettings.testTargetTitle : null);
        String runTestEnvironmentTitle = vr.replace(sourceSettings != null ? sourceSettings.testEnvironmentTitle : null);
        String runTags = vr.replace(tags);
        String runAssignToUser = vr.replace(sourceSettings != null ? sourceSettings.assignToUser : null);
        String runTestCaseMappingField = vr.replace(sourceSettings != null ? sourceSettings.testCaseMappingField : null);
        String runSource = vr.replace(source);

        String runParameterVariables = vr.replace(parameters);
        Map<String, String> runParameters = null;
        if(runParameterVariables != null && runParameterVariables.trim().length() > 0) {
            String[] pars = runParameterVariables.split(",");
            Map<String, String> vars = vr.getVars();
            for(String par : pars) {
                par = par.trim();
                String value = vars.get(par);
                if(value == null)
                    value = vars.get(par.toUpperCase());
                if(value != null) {
                    if(runParameters == null)
                        runParameters = new HashMap<String, String>();
                    runParameters.put(par, value);
                }
            }
        }

        String runTapMappingPrefix = vr.replace(publishTap != null ? publishTap.tapMappingPrefix : null);       // nop on null

        FilePath workspace = build.getWorkspace();

        String abortError = null;
        if(workspace == null) {
            abortError = "The provided build has no workspace.";
        }

        if(!runUsingonpremise && isBlank(runCompanyId)) {
            abortError = "Could not publish results to Testlab: Company ID is not set. Configure it for your job or globally in Jenkins' configuration.";
        }

        if(runUsingonpremise && isBlank(runOnpremiseurl)) {
            abortError = "Could not publish results to Testlab: Testlab URL for on-premise Testlab is not set. Configure it for your job or globally in Jenkins' configuration.";
        }

        if(isBlank(runApiKey)) {
            abortError = "Could not publish results to Testlab: Api Key is not set. Configure it for your job or globally in Jenkins' configuration.";
        }

        if(isBlank(runTestCaseMappingField)) {
            abortError = "Could not publish results to Testlab: Test case mapping field is not set. Configure it for your job or globally in Jenkins' configuration or, if the value contains variable tags make sure they have values.";
        }

        if(isBlank(runProjectKey)) {
            abortError = "Could not publish results to Testlab: Project key is not set. Configure it for your job or, if the value contains variable tags make sure they have values.";
        }

        if(isBlank(runTestRunTitle)) {
            abortError = "Could not publish results to Testlab: Test run title is not set. Configure it for your job or, if the value contains variable tags make sure they have values.";
        }

        if(abortError != null) {
            listener.error(abortError);
            throw new AbortException(abortError);
        }

        Sender.sendResults(
                workspace,
                runCompanyId,
                runUsingonpremise,
                runOnpremiseurl,
                runApiKey,
                runProjectKey,
                runSource,
                runMilestone,
                runTestRunTitle,
                runComment,
                runTestTargetTitle,
                runTestEnvironmentTitle,
                runTags,
                runParameters,
                sourceSettings != null ? sourceSettings.addIssues : null,
                sourceSettings != null ? sourceSettings.mergeAsSingleIssue : false,     // TODO: null
                sourceSettings != null ? sourceSettings.reopenExisting : false,     // TODO: null
                !isBlank(runAssignToUser) ? runAssignToUser : null,
                publishTap != null,
                publishTap != null ? publishTap.tapTestsAsSteps : null,
                publishTap != null ? publishTap.tapFileNameInIdentifier : null,
                publishTap != null ? publishTap.tapTestNumberInIdentifier : null,
                runTapMappingPrefix,
                sourceSettings != null ? sourceSettings.importTestCases : null,
                sourceSettings != null ? sourceSettings.importTestCasesRootCategory : null,
                runTestCaseMappingField,
                publishRobot != null,
                publishRobot != null ? publishRobot.robotOutput : null,
                sourceSettings != null ? sourceSettings.robotCatenateParentKeywords : null,
                build
        );

        return true;
    }

    @Override
    public DescriptorImpl getDescriptor() {
        // see Descriptor javadoc for more about what a descriptor is.
        return (DescriptorImpl)super.getDescriptor();
    }

    // this annotation tells Hudson that this is the implementation of an extension point
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {
        // company id of the testlab which to publish to
        public String companyId;
        // testlab api key
        public String apiKey;
        // if set, on-premise variant of Testlab is used and Testlab URL should be set and honored
        public Usingonpremise usingonpremise;
        // defines CORS settings for calls from Testlab -> Jenkins API
        public Cors cors;

        /* pre-source configuration, see readResolve */
        // custom field name to map the test ids against with
        private transient String testCaseMappingField;
        /* /pre-source configuration, see readResolve */

        private CORSFilter CORSFilter;

        public DescriptorImpl() {
            load();

            log.fine("load: " + companyId + ", api key hidden, " + usingonpremise + ", " + usingonpremise + ", " + cors);

            if(!isBlank(testCaseMappingField)) {
                log.warning(
                        "Meliora Testlab Plugin: In plugin settings, you have 'Test case mapping field' set" +
                        " as '" + testCaseMappingField + "'. This field is deprecated and should be set to each job's" +
                        " source overrides or at Testlab side in source's settings. See the plugin documentation on" +
                        " changes related to the introduction of source-concept in Testlab. As deprecated, this value" +
                        " will be ignored."
                );
            }

            // let's inject our CORSFilter as we're at it
            try {
                CORSFilter = new CORSFilter();
                PluginServletFilter.addFilter(CORSFilter);
                log.info("CORSFilter injected.");
            } catch (ServletException se) {
                log.warning("Could not inject CORSFilter.");
                se.printStackTrace();
            }

            configureCORS();
        }

        /**
         * This human readable name is used in the configuration screen.
         */
        @Override
        public String getDisplayName() {
            return "Publish test results to Testlab";
        }

        /**
         * Applicable to any kind of project.
         */
        @Override
        public boolean isApplicable(Class type) {
            return true;
        }

        @Override
        public boolean configure(StaplerRequest staplerRequest, JSONObject json) throws Descriptor.FormException {
            // persist configuration
            companyId = json.getString("companyId");
            apiKey = json.getString("apiKey");

            JSONObject uop = json.getJSONObject("usingonpremise");
            if(uop != null && !uop.isNullObject() && !uop.isEmpty()) {
                usingonpremise = new Usingonpremise(uop.getString("onpremiseurl"));
            } else {
                usingonpremise = null;
            }

            JSONObject c = json.getJSONObject("cors");
            if(c != null && !c.isNullObject() && !c.isEmpty()) {
                cors = new Cors(c.getString("origin"));
            } else {
                cors = null;
            }

            log.fine("configure: " + companyId + ", api key hidden, " + usingonpremise + ", " + cors);

            save();

            configureCORS();

            return true; // indicate that everything is good so far
        }

        protected void configureCORS() {
            CORSFilter.setEnabled(cors != null && !isBlank(cors.origin));
            if(cors != null && cors.origin != null) {
                //
                // parse a comma separated list to a list of allowed origins
                //
                String[] spl = cors.origin.split(",");
                List<String> origins = new ArrayList<String>();
                for(String o : spl) {
                    origins.add(o.trim());
                }
                CORSFilter.setOrigins(origins);
            }
        }
        
        public String getDefaultCommentTemplate() {
            return DEFAULT_COMMENT_TEMPLATE;
        }

        @Override
        public String toString() {
            return "DescriptorImpl{" +
                    "companyId='" + companyId + '\'' +
                    ", apiKey='hidden'" +
                    ", usingonpremise=" + usingonpremise +
                    ", cors=" + cors +
                    '}';
        }
    }

    /**
     * Optional job config block for source settings.
     *
     * If set implicitly implies that some source settings should be overridden.
     */
    public static final class SourceSettings {
        // name of the test run to create or update at Testlab side
        public String testRunTitle;
        // identifier or a title of a milestone the results are bound to in Testlab
        public String milestone;
        // title of the version the results are bound to in Testlab
        public String testTargetTitle;
        // title of the environment the results are bound to in Testlab
        public String testEnvironmentTitle;
        // issues are added for failed tests ?
        public Boolean addIssues;
        // if true added issues are merged and added as a single issue
        public Boolean mergeAsSingleIssue;
        // if set we try to reopen existing matching issues on push
        public Boolean reopenExisting;
        // if set issues are automatically assigned to this user
        public String assignToUser;
        // if true we try to automatically create test cases for tests
        public Boolean importTestCases;
        // test category where the automatically created test cases will be created to. Defaults to 'Import'.
        public String importTestCasesRootCategory;
        // if set, all keywords and their sub keywords are catenated to a single step in the result when possible
        public Boolean robotCatenateParentKeywords;
        // testlab field to use to store the mapping ID's of automated tests when automatically creating test cases
        public String testCaseMappingField;

        public SourceSettings() {}

        @DataBoundConstructor
        public SourceSettings(String testRunTitle, String milestone, String testTargetTitle, String testEnvironmentTitle, Boolean addIssues, Boolean mergeAsSingleIssue, Boolean reopenExisting, String assignToUser, Boolean importTestCases, String importTestCasesRootCategory, Boolean robotCatenateParentKeywords, String testCaseMappingField) {
            this.testRunTitle = testRunTitle;
            this.milestone = milestone;
            this.testTargetTitle = testTargetTitle;
            this.testEnvironmentTitle = testEnvironmentTitle;
            this.addIssues = addIssues;
            this.mergeAsSingleIssue = mergeAsSingleIssue;
            this.reopenExisting = reopenExisting;
            this.assignToUser = assignToUser;
            this.importTestCases = importTestCases;
            this.importTestCasesRootCategory = importTestCasesRootCategory;
            this.robotCatenateParentKeywords = robotCatenateParentKeywords;
            this.testCaseMappingField = testCaseMappingField;
        }

        @Override
        public String toString() {
            return "SourceSettings{" +
                    "testRunTitle='" + testRunTitle + '\'' +
                    ", milestone='" + milestone + '\'' +
                    ", testTargetTitle='" + testTargetTitle + '\'' +
                    ", testEnvironmentTitle='" + testEnvironmentTitle + '\'' +
                    ", addIssues=" + addIssues +
                    ", mergeAsSingleIssue=" + mergeAsSingleIssue +
                    ", reopenExisting=" + reopenExisting +
                    ", assignToUser='" + assignToUser + '\'' +
                    ", importTestCases=" + importTestCases +
                    ", importTestCasesRootCategory='" + importTestCasesRootCategory + '\'' +
                    ", robotCatenateParentKeywords=" + robotCatenateParentKeywords +
                    ", testCaseMappingField='" + testCaseMappingField + '\'' +
                    '}';
        }
    }

    /**
     * Optional job config block for advanced settings.
     */
    public static final class AdvancedSettings {
        // job specific company ID of target testlab, optional
        public String companyId;
        // if set, on-premise variant of Testlab is used and Testlab URL should be set and honored
        public Usingonpremise usingonpremise;
        // job specific apikey of target testlab, optional
        public String apiKey;
        /* pre-source configuration, see readResolve */
        // title of the Testlab custom field to use to map the unit tests to Testlab's test cases, optional
        public transient String testCaseMappingField;
        /* /pre-source configuration, see readResolve */

        @DataBoundConstructor
        public AdvancedSettings(String companyId, String apiKey, String testCaseMappingField, Usingonpremise usingonpremise) {
            this.companyId = companyId;
            this.apiKey = apiKey;
            this.usingonpremise = usingonpremise;
            this.testCaseMappingField = testCaseMappingField;
        }

        @Override
        public String toString() {
            return "AdvancedSettings{" +
                    "companyId='" + companyId + '\'' +
                    ", usingonpremise=" + usingonpremise +
                    ", apiKey='hidden'" +
                    '}';
        }
    }

    /**
     * Optional job config block for on-premise settings.
     */
    public static final class Usingonpremise {
        // full url address of on-premise Testlab
        public String onpremiseurl;

        @DataBoundConstructor
        public Usingonpremise(String onpremiseurl) {
            this.onpremiseurl = onpremiseurl;
        }

        @Override
        public String toString() {
            return "Usingonpremise{" +
                    "onpremiseurl='" + onpremiseurl + '\'' +
                    '}';
        }
    }

    /**
     * Optional job config block for issues.
     *
     * If set implicitly implies that issues should be added on push.
     */
    public static final class IssuesSettings {
        // if true added issues are merged and added as a single issue
        public boolean mergeAsSingleIssue;
        // if set issues are automatically assigned to this user
        public String assignToUser;
        // if set we try to reopen existing matching issues on push
        public boolean reopenExisting;

        @DataBoundConstructor
        public IssuesSettings(boolean mergeAsSingleIssue, String assignToUser, boolean reopenExisting) {
            this.mergeAsSingleIssue = mergeAsSingleIssue;
            this.assignToUser = assignToUser;
            this.reopenExisting = reopenExisting;
        }

        @Override
        public String toString() {
            return "IssuesSettings{" +
                    "mergeAsSingleIssue=" + mergeAsSingleIssue +
                    ", assignToUser='" + assignToUser + '\'' +
                    ", reopenExisting=" + reopenExisting +
                    '}';
        }
    }

    /**
     * Optional config block for CORS settings.
     */
    public static final class Cors {
        // allow origin
        public String origin;

        @DataBoundConstructor
        public Cors(String origin) {
            this.origin = origin;
        }

        @Override
        public String toString() {
            return "Cors{" +
                    "origin='" + origin + '\'' +
                    '}';
        }
    }

    /**
     * Optional job config block for TAP support.
     *
     * If set implicitly implies that TAP results should be published to Testlab.
     */
    public static final class PublishTap {
        // If set, each TAP file will be mapped to a single test case in Testlab and the steps of the test case will be overwritten and matched to sent lines in TAP file
        public boolean tapTestsAsSteps;
        // If set, the name of the TAP file containing the tests is included in the mapping identifier as a prefix
        public boolean tapFileNameInIdentifier;
        // If set, the mapping identifier will not include the test number of the TAP test
        public boolean tapTestNumberInIdentifier;
        // If set, mapping identifiers sent will be prefixed with this value
        public String tapMappingPrefix;

        @DataBoundConstructor
        public PublishTap(boolean tapFileNameInIdentifier, boolean tapTestNumberInIdentifier, boolean tapTestsAsSteps, String tapMappingPrefix) {
            this.tapFileNameInIdentifier = tapFileNameInIdentifier;
            this.tapTestNumberInIdentifier = tapTestNumberInIdentifier;
            this.tapTestsAsSteps = tapTestsAsSteps;
            this.tapMappingPrefix = tapMappingPrefix;
        }

        @Override
        public String toString() {
            return "PublishTap{" +
                    "tapFileNameInIdentifier=" + tapFileNameInIdentifier +
                    ", tapTestsAsSteps=" + tapTestsAsSteps +
                    ", tapTestNumberInIdentifier=" + tapTestNumberInIdentifier +
                    ", tapMappingPrefix=" + tapMappingPrefix +
                    '}';
        }
    }

    /**
     * Optional job config block for Robot Framework support.
     *
     * If set implicitly implies that Robot results should be published to Testlab.
     */
    public static final class PublishRobot {
        // Robot output.xml file path
        public String robotOutput;

        /* pre-source configuration, see readResolve */
        // If set, catenates all sub keywords of a keyword as a single step in result
        public transient Boolean robotCatenateParentKeywords = true;
        /* /pre-source configuration, see readResolve */

        @DataBoundConstructor
        public PublishRobot(String robotOutput, Boolean robotCatenateParentKeywords) {
            this.robotOutput = robotOutput;
            this.robotCatenateParentKeywords = robotCatenateParentKeywords;
        }

        @Override
        public String toString() {
            return "PublishRobot{" +
                    "robotOutput='" + robotOutput + '\'' +
                    '}';
        }
    }

    /**
     * Optional job config block for auto-creating test cases.
     *
     * If set implicitly implies that test cases should be automatically created during the push.
     */
    public static final class ImportTestCases {
        // If set, sets the root category path where the test cases are created. By default, "Import".
        public String importTestCasesRootCategory;

        @DataBoundConstructor
        public ImportTestCases(String importTestCasesRootCategory) {
            this.importTestCasesRootCategory = importTestCasesRootCategory;
        }

        @Override
        public String toString() {
            return "ImportTestCases{" +
                    "importTestCasesRootCategory='" + importTestCasesRootCategory + '\'' +
                    '}';
        }
    }

    /**
     * @return true if trimmed String is empty
     */
    public static boolean isBlank(String s) {
        return s == null || s.trim().length() == 0;
    }

    @Override
    public String toString() {
        return "TestlabNotifier{" +
                "projectKey='" + projectKey + '\'' +
                ", source='" + source + '\'' +
                ", sourceSettings=" + sourceSettings +
                ", comment='" + comment + '\'' +
                ", tags='" + tags + '\'' +
                ", parameters='" + parameters + '\'' +
                ", publishRobot=" + publishRobot +
                ", publishTap=" + publishTap +
                ", advancedSettings=" + advancedSettings +
                ", descriptor=" + getDescriptor() +
                "}";
    }
}
